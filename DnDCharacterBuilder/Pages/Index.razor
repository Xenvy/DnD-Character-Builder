@page "/"

@inject IArmorData armorData
@inject IBackgroundData backgroundData
@inject ICharacterClassFeatureData characterClassFeatureData
@inject ICharacterClassLevelData characterClassLevelData
@inject IFeatData featData
@inject IRaceData raceData
@inject IRacialFeatureData racialFeatureData
@inject ISkillData skillData
@inject ISpellData spellData
@inject IWeaponData weaponData
@inject ICharacterSheetData characterSheetData
@inject ICharacterSheet characterSheet
@inject NavigationManager navManager
@inject ProtectedSessionStorage sessionStorage

<PageTitle>DnD Character Builder</PageTitle>

<body class="character-sheet">
	<h1>Character Sheet</h1>
	<div class="summary-section sheet-row">
		<p>Level @characterSheet.CharacterLevel @characterSheet.Race?.Name Adventurer
			@if(characterSheet.CharacterClassLevels.Any())
			{
				@(" /")
				@foreach(var cl in characterSheet.CharacterClassLevels.DistinctBy(x => x.BaseClass))
				{
					@($"/ {cl.BaseClass} ")
				}
			}
		</p>
	</div>
	<div class="core-stats-section sheet-row">
		<p>Core stats <br/>
			Hit points: @characterSheet.HitPoints </p>
		<p><br/>Speed: @characterSheet.Speed</p>
	</div>
	<!-- Race and race features section -->
	<div class="race-section sheet-row">
		<div class="race-choice-section">
			<div class="autocomplete">
				<div class="option-selection">
					<label for="raceSelection">Race: @(characterSheet.Race?.Name)</label>
					@if(characterSheet.Race is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => showRaceSelect = !showRaceSelect)"><span class="oi oi-loop-circular"></span></button>
					}
					else
					{
						<br />
						<button class="btn btn-outline-dark" @onclick="(_ => showRaceSelect = !showRaceSelect)">Select a race</button>
					}
					@if(showRaceSelect)
					{
						<!-- Autocomplete-style selection of character's race -->
						<input type="text"
							   id="raceSelection"
							   placeholder="Search..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnRaceSearchInput((string)txt.Value))"
							   @bind-value="raceSearchText" />
						<div class="option-list">
							<ul name="raceSelectionList" class="options">
								@if (races?.Count > 0)
								{
									@foreach (var r in races)
									{
										<li class="option" @onclick="(_ => SelectRace(r))">
											<span class="option-text">@r.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}
				</div>
			</div>
		</div>
		<div class="race-features-section">
			@if(characterSheet.Race is not null)
			{
				<p>@characterSheet.Race.Name features:</p>
				@foreach (var rf in characterSheet.Race.RaceFeatures)
				{
					@if (!String.IsNullOrWhiteSpace(rf.Description))
					{
						<div class="feature-with-tooltip">
							@rf.Name
							<span class="tooltip-text"> @rf.Description </span>
						</div>
					}
					else
					{
						<div class="feature-no-tooltip">@rf.Name</div>
					}
				}
			}
		</div>
	</div>
	<!-- Ability scores section -->
	<div class="ability-scores-section sheet-row">
		<!-- Display character's ability scores alongside increment and decrement buttons -->
		<div class="ability-score-points">
			<p>Ability scores <br />
				Remaining points: @characterSheet.AbilityScorePoints
			</p>
		</div>
		<div class="ability-scores">
			@foreach (var a in characterSheet.AbilityScores)
			{
				<div class="ability-score-entry">
					@($"{a.Key.ToString()}: {a.Value.Value} [{a.Value.Modifier}]")
					<button class="btn btn-light as-subtract-btn @(a.Value.Value > 8 ? "" : "disabled disabled-btn")" @onclick="(_ => DecreaseAbilityScore(a.Value))">-</button>
					<button class="btn btn-light as-add-btn @(a.Value.CanIncrease && characterSheet.AbilityScorePoints >= a.Value.IncreaseCost ? "" : "disabled disabled-btn")" @onclick="(_ => IncreaseAbilityScore(a.Value))">+</button>
				</div>
			}
		</div>				
	</div>
	<!-- Background section -->
	<div class="background-section sheet-row">	
		<div class="autocomplete">
			<div class="option-selection">
				<label for="backgroundSelection">Background: @(characterSheet.Background?.Name)</label>
				@if (characterSheet.Background is not null)
				{
					<button class="btn btn-sm" @onclick="(_ => showBackgroundSelect = !showBackgroundSelect)"><span class="oi oi-loop-circular"></span></button>
				}
				else
				{
					<br />
					<button class="btn btn-outline-dark" @onclick="(_ => showBackgroundSelect = !showBackgroundSelect)">Select a background</button>
				}
				@if(showBackgroundSelect)
				{
					<!-- Autocomplete-style selection of character's background -->
					<input type="text"
						   id="backgroundSelection"
						   placeholder="Search..."
						   class="form-control filter"
						   aria-label="Search box"
						   @oninput="((txt) => OnBackgroundSearchInput((string)txt.Value))"
						   @bind-value="backgroundSearchText" />
					<div class="option-list">
						<ul name="backgroundSelectionList" class="options">
							@if (backgrounds?.Count > 0)
							{
								@foreach (var b in backgrounds)
								{
									<li class="option" @onclick="(_ => SelectBackground(b))">
										<span class="option-text">@b.Name</span>
									</li>
								}
							}
							else
							{
								<li class="disabled option">No results</li>
							}
						</ul>
					</div>
				}
			</div>					
		</div>
	</div>
	<!-- Skills and saving section throw proficiencies section -->
	<div class="skills-and-saving-throws-section sheet-row">
		<div class="skills-section">
			<p>Character skills</p>
			<!-- Display all skills and their values -->
			<table name="skillsTable" class="table table-striped skills-table">
				<thead>
					<tr>
						<th>Skill</th>
						<th>Ability</th>
						<th>Ability Bonus</th>
						<th>Skill Proficiency Bonus</th>
						<th>Total</th>
					</tr>
				</thead>
				<tbody>
					@foreach (var s in skills)
					{
						<tr>
							<td>@s.Name</td>
							<td>@s.AssociatedAbilityScore</td>
							<td>@characterSheet.AbilityScores[s.AssociatedAbilityScore].Modifier</td>
							<td>@(characterSheet.SkillProficiencies.Find(x => x.Name == s.Name) == null ? 0 : characterSheet.SkillExpertise.Find(x => x.Name == s.Name) == null ? characterSheet.ProficiencyBonus : 2*characterSheet.ProficiencyBonus)</td>
							<td>@(@characterSheet.AbilityScores[s.AssociatedAbilityScore].Modifier + (characterSheet.SkillProficiencies.Find(x => x.Name == s.Name) == null ? 0 : characterSheet.SkillExpertise.Find(x => x.Name == s.Name) == null ? characterSheet.ProficiencyBonus : 2 * characterSheet.ProficiencyBonus))</td>
						</tr>		
					}
				</tbody>		
			</table>
		</div>
		<div class="saving-throws-section">
			<p>Saving throws</p>
			<table name="savingThrowsTable" class="table table-striped saving-throws-table">
				<thead>
					<tr>
						<th>Saving Throw</th>
						<th>Ability Bonus</th>
						<th>Proficiency Bonus</th>
						<th>Total</th>
					</tr>
				</thead>
				<tbody>
					@foreach (var a in characterSheet.AbilityScores)
					{
						<tr>
							<td>@a.Key.ToString()</td>
							<td>@a.Value.Modifier</td>
							<td>@(characterSheet.SavingThrowProficiencies.FindIndex(x => x == a.Key) != -1 ? characterSheet.ProficiencyBonus : 0)</td>
							<td>@(a.Value.Modifier + (characterSheet.SavingThrowProficiencies.FindIndex(x => x == a.Key) != -1 ? characterSheet.ProficiencyBonus : 0))</td>
						</tr>
					}
				</tbody>
			</table>
		</div>
		<div>
			<p>Feats</p>
			@foreach (var f in characterSheet.Feats)
			{
				<div class="feature-with-tooltip">
					@f.Name
					<span class="tooltip-text"> @f.Description </span>
				</div>
			}
		</div>
	</div>
	<!-- Weapon and armor section -->
	<div class="weapons-and-armors-section sheet-row">
		<div class="weapons-section">
			<div class="weapon-proficiencies">
				<label for="weaponProficiencies">Weapon proficiencies:</label>
				<ul name="weaponProficiencies">
					@foreach (var w in characterSheet.DisplayedWeaponProficiencies)
					{
						<li>@w</li>
					}
				</ul>
			</div>
			<div class="autocomplete">
				<div class="option-selection">
					<label for="weapon1Selection">Main hand: @characterSheet.EquippedWeapons[0]?.Name</label>
					@if (characterSheet.EquippedWeapons[0].Name is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => MainHandSelect())"><span class="oi oi-loop-circular"></span></button>
					}
					else
					{
						<br />
						<button class="btn btn-outline-dark" @onclick="(_ => MainHandSelect())">Select a weapon</button>
					}
					@if(showWeapon1Select)
					{
						<!-- Autocomplete-style selection of character's main hand weapon -->
						<input type="text"
							   id="weapon1Selection"
							   placeholder="Search..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnWeapon1SearchInput((string)txt.Value))"
							   @bind-value="weapon1SearchText" />
						<div class="option-list">
							<ul name="weaponSelectionList" class="options">
								@if (weapons?.Count > 0)
								{
									<li class="option" @onclick="(_ => SelectWeapon(new Weapon(), 0))"><span class="option-text">(Empty hand)</span></li>
									@foreach (var w in weapons)
									{
										<li class="option" @onclick="(_ => SelectWeapon(w, 0))">
											<span class="option-text">@w.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}
				</div>
			</div>
			<div>
				<p>Main hand attack: @characterSheet.EquippedWeapons[0].Name @($"+{characterSheet.AbilityScores[0].Modifier + characterSheet.ProficiencyBonus}") @($"{characterSheet.EquippedWeapons[0].Damage}+{characterSheet.AbilityScores[0].Modifier}")</p>
			</div>
			@if(characterSheet.EquippedWeapons[0]?.TwoHanded == false)
			{
				<div class="autocomplete">
					<div class="option-selection">
						<label for="weapon2Selection">Off hand: @characterSheet.EquippedWeapons[1]?.Name</label>
						@if (characterSheet.EquippedWeapons[1].Name is not null)
						{
							<button class="btn btn-sm" @onclick="(_ => OffHandSelect())"><span class="oi oi-loop-circular"></span></button>
						}
						else
						{
							<br />
							<button class="btn btn-outline-dark" @onclick="(_ => OffHandSelect())">Select a weapon</button>
						}
						@if(showWeapon2Select)
						{
							<!-- Autocomplete-style selection of character's off-hand weapon -->
							<input type="text"
								   id="weapon2Selection"
								   placeholder="Search..."
								   class="form-control filter"
								   aria-label="Search box"
								   @oninput="((txt) => OnWeapon2SearchInput((string)txt.Value))"
								   @bind-value="weapon2SearchText" />
							<div class="option-list">
								<ul name="weaponSelectionList" class="options">
									@if (weapons?.Count > 0)
									{
										<li class="option" @onclick="(_ => SelectWeapon(new Weapon(), 1))"><span class="option-text">(Empty hand)</span></li>
										@foreach (var w in weapons)
										{
											<li class="option" @onclick="(_ => SelectWeapon(w, 1))">
												<span class="option-text">@w.Name</span>
											</li>
										}
									}
									else
									{
										<li class="disabled option">No results</li>
									}
								</ul>
							</div>
						}	
					</div>
				</div>
				<div>
					<p>Off-hand attack: @characterSheet.EquippedWeapons[1].Name @($"+{characterSheet.AbilityScores[0].Modifier + characterSheet.ProficiencyBonus}") @characterSheet.EquippedWeapons[1].Damage</p>
				</div>
			}
		</div>
		<div class="armor-section">
			<div class="armor-proficiencies">
				<label for="armorProficiencies">Armor proficiencies:</label>
				<ul name="armorProficiencies">
					@foreach (var a in characterSheet.ArmorProficiencies)
					{
						<li>@a</li>
					}
				</ul>
			</div>
			<div class="autocomplete">
				<div class="option-selection">
					<label for="armorSelection">Equipped armor: @characterSheet.EquippedArmor.Name</label>
					@if (characterSheet.EquippedArmor.Name is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => showArmorSelect = !showArmorSelect)"><span class="oi oi-loop-circular"></span></button>
					}
					else
					{
						<br />
						<button class="btn btn-outline-dark" @onclick="(_ => showArmorSelect = !showArmorSelect)">Select armor</button>
					}
					@if(showArmorSelect)
					{
						<!-- Autocomplete-style selection of character's armor -->
						<input type="text"
							   id="armorSelection"
							   placeholder="Search..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnArmorSearchInput((string)txt.Value))"
							   @bind-value="armorSearchText" />
						<div class="option-list">
							<ul name="armorSelectionList" class="options">
								@if (armors?.Count > 0)
								{
									<li class="option" @onclick="(_ => SelectArmor(new Armor()))"><span class="option-text">(No armor)</span></li>
									@foreach (var a in armors)
									{
										<li class="option" @onclick="(_ => SelectArmor(a))">
											<span class="option-text">@a.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}		
				</div>
			</div>
			<div>
				<p>Current Armor Class: @(characterSheet.EquippedArmor.Name is null ? 10 : characterSheet.EquippedArmor.ArmorClass) base + @(characterSheet.AbilityScores[CharacterBuilderLibrary.Ability.Dexterity].Modifier > characterSheet.EquippedArmor.MaxDexBonus ? characterSheet.EquippedArmor.MaxDexBonus : characterSheet.AbilityScores[CharacterBuilderLibrary.Ability.Dexterity].Modifier) dexterity bonus</p>
			</div>
		</div>
	</div>
	<!-- Spells section -->
	<div class="spells-section sheet-row">
		<div>
			<p>Spells</p>
			@if (characterSheet.CharacterClassLevels.Count > 0)
			{
				@foreach (var cl in Enumerable.Range(0, characterSheet.CharacterClassLevels.Count))
				{
					@if(characterSheet.CharacterClassLevels[cl].SpellsLearned.Count > 0)
					{
						<p>@($"{characterSheet.CharacterClassLevels[cl].BaseClass} - {characterSheet.CharacterClassLevels[cl].Subclass} level {characterSheet.CharacterClassLevels[cl].Level}") spells:</p>
						@foreach (var s in characterSheet.CharacterClassLevels[cl].SpellsLearned)
						{
							<div class="feature-with-tooltip">
								@s.Name
								<span class="spell-tooltip-text"> @s.Description </span>
							</div>
							<button class="btn btn-light remove-spell-button" @onclick="(_ => RemoveSpell(s, characterSheet.CharacterClassLevels[cl]))">-</button>
						}
					}
					@if (characterSheet.CharacterClassLevels[cl].GetNewSpellCount() > characterSheet.CharacterClassLevels[cl].SpellsLearned.Count)
					{
						<div class="autocomplete">
							<div class="option-selection">
								<span>
									Select spells for @characterSheet.CharacterClassLevels[cl].BaseClass - @characterSheet.CharacterClassLevels[cl].Subclass level @characterSheet.CharacterClassLevels[cl].Level
									(@(characterSheet.CharacterClassLevels[cl].GetNewSpellCount() - characterSheet.CharacterClassLevels[cl].SpellsLearned.Count) remaining)</span>
								<button class="btn btn-outline-dark" @onclick="(_ => OnSpellSelectToggle(characterSheet.CharacterClassLevels[cl], cl))">Select a spell</button>
								@if (showSpellSelect[cl])
								{
									<!-- Autocomplete-style selection of character's spells -->
									<input type="text"
										   id="spellSelection"
										   placeholder="Search..."
										   class="form-control filter"
										   aria-label="Search box"
										   @bind-value="spellSearchText"
										   @oninput="((txt) => OnSpellSearchInput((string)txt.Value, characterSheet.CharacterClassLevels[cl]))" />
									<div class="option-list">
										<ul name="spellSelectionList" class="options">
											@if (spells?.Count > 0)
											{
												@foreach (var s in spells)
												{
													<li class="option" @onclick="(_ => AddSpell(s, characterSheet.CharacterClassLevels[cl], cl))">
														<span class="option-text">@s.Name</span>
													</li>
												}
											}
											else
											{
												<li class="disabled option">No results</li>
											}
										</ul>
									</div>
								}
							</div>
						</div>
					}		
				}
				@if(characterSheet.BonusSpells.Any())
				{
					<p>Bonus spells:</p>
					@foreach (var b in characterSheet.BonusSpells)
					{
						<div class="feature-with-tooltip">
							@b.Name
							<span class="spell-tooltip-text"> @b.Description </span>
						</div>
					}
				}
			}
		</div>
	</div>
	<!-- Class levels and features section -->
	<div class="levels-section sheet-row">
		<div class="level-choice-section">
			<p>
				Levels:
				<br />
				<!-- Display all current character's levels -->
				@if (characterSheet.CharacterClassLevels.Count > 0)
				{
					@foreach (var cl in characterSheet.CharacterClassLevels)
					{
						@($"{cl.BaseClass} - {cl.Subclass} {cl.Level} ")
						<button class="btn btn-light" @onclick="(_ => RemoveClassLevel(cl))">-</button>
						<br />
					}
				}
			</p>
			@if (characterSheet.CharacterClassLevels.Count < 20)
			{
				<div class="autocomplete">
					<div class="option-selection">
						<button class="btn btn-outline-dark" @onclick="(_ => OnClassLevelSelectToggle())">Add a class level</button>
						@if (showClassLevelSelect)
						{
							<!-- Autocomplete-style selection of character's class levels -->
							<input type="text"
								   id="classLevelSelection"
								   placeholder="Search..."
								   class="form-control filter"
								   aria-label="Search box"
								   @bind-value=classLevelSearchText
								   @oninput="((txt) => OnClassLevelSearchInput((string)txt.Value))" />
							<div class="option-list">
								<ul name="classLevelSelection" class="options">
									@if (characterClassLevels?.Count > 0)
									{
										@foreach (var cl in characterClassLevels)
										{
											<li class="option" @onclick="(_ => AddClassLevel(cl))">
												<span class="option-text">@($"{cl.BaseClass} - {cl.Subclass} {cl.Level}")</span>
											</li>
										}
									}
									else
									{
										<li class="disabled option">No results</li>
									}
								</ul>
							</div>
						}	
					</div>
				</div>
			}		
		</div>
		<div class="level-features-section">
			<!-- Display all acquired level features, grouped by level -->
			@if (characterSheet.CharacterClassLevels.Count > 0)
			{
				@foreach (var cl in Enumerable.Range(0, characterSheet.CharacterClassLevels.Count))
				{
					<p>Character level @(cl + 1) / @($"{characterSheet.CharacterClassLevels[cl].BaseClass} - {characterSheet.CharacterClassLevels[cl].Subclass} level {characterSheet.CharacterClassLevels[cl].Level}") features:</p>
					@foreach (var f in characterSheet.CharacterClassLevels[cl].ClassLevelFeatures)
					{
						@if (!String.IsNullOrWhiteSpace(f.Description))
						{
							<div class="feature-with-tooltip">
								@f.Name
								<span class="tooltip-text"> @f.Description </span>
							</div>
						}
						else
						{
							<div class="feature-no-tooltip">@f.Name</div>
						}
						<!--Class feature tag parser-->
						@foreach (var te in f.TagEntries)
						{
							switch(te.Tag)
							{
								case "skillSelectAny":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SkillSubselection skillProficiencies="characterSheet.SkillProficiencies" @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveSkillProficiencyFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "skillSelect":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SkillSubselection skillProficiencies="characterSheet.SkillProficiencies" 
														   tagArguments="te.Arguments"
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveSkillProficiencyFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "skillSelectExpertise":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SkillSubselection skillProficiencies="characterSheet.SkillProficiencies"
														   skillExpertise="characterSheet.SkillExpertise"
														   tagArguments="te.Arguments"
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveSkillAndExpertiseFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "expertise":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SkillSubselection skillProficiencies="characterSheet.SkillProficiencies"
														   skillExpertise="characterSheet.SkillExpertise"
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveSkillExpertiseFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "spellSelect":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SpellSubselection classLevel="characterSheet.CharacterClassLevels[cl]"
														   bonusSpells="characterSheet.BonusSpells"
														   tagArguments="te.Arguments"
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveBonusSpellFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "spellSelectAny":
									@if(string.IsNullOrEmpty(te.TagData[0]))
									{
										<SpellSubselection classLevel="characterSheet.CharacterClassLevels[cl]" 
														   bonusSpells="characterSheet.BonusSpells" 
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveBonusSpellFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "spellMastery":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<SpellSubselection classLevel="characterSheet.CharacterClassLevels[cl]"
														   bonusSpells="characterSheet.BonusSpells"
														   spellChoice="characterSheet.GetAllClassSpellsByLevel(int.Parse(te.Arguments[0]))"
														   tagArguments="te.Arguments"
														   @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => te.TagData = new string[2])">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								case "feat":
									@if (string.IsNullOrEmpty(te.TagData[0]))
									{
										<FeatSubselection characterFeats="characterSheet.Feats" @bind-tagData="te.TagData" />
									}
									else
									{
										<button class="btn btn-sm" @onclick="(_ => RemoveFeatFromTag(te))">(@te.TagData[1] <span class="oi oi-loop-circular"></span>)</button>
									}
									break;
								default:
									break;
							}
						}
						@if(f.SubfeatureSelections > 0)
						{
							@foreach (var subf in Enumerable.Range(0, f.SubfeatureSelections))
							{
								if (subf >= f.SubselectionsMade.Count)
								{
									<FeatureSubselection @bind-classLevel="characterSheet.CharacterClassLevels[cl]" classFeature="f" />
								}
							}
						}
						@if (!string.IsNullOrEmpty(f.ParentFeatureName) && characterSheet.CharacterClassLevels[cl].ClassLevelFeatures.Find(x => x.Name == f.ParentFeatureName)?.SubfeatureSelections > 0)
						{
							<button class="btn btn-sm" @onclick="(_ => RemoveSubfeature(characterSheet.CharacterClassLevels[cl], f))"><span class="oi oi-loop-circular"></span></button>
						}
					}
				}
			}
		</div>
	</div>
</body>

@code
{
	private List<Armor> armors = new();
	private List<Background> backgrounds = new();
	private List<CharacterClassFeature> characterClassFeatures = new();
	private List<CharacterClassLevel> characterClassLevels = new();
	private List<Feat> feats = new();
	private List<Race> races = new();
	private List<RacialFeature> racialFeatures = new();
	private List<Skill> skills = new();
	private List<Spell> spells = new();
	private List<Weapon> weapons = new();

	private string backgroundSearchText = "";
	private string raceSearchText = "";
	private string weapon1SearchText = "";
	private string weapon2SearchText = "";
	private string armorSearchText = "";
	private string classLevelSearchText = "";
	private string spellSearchText = "";

	private bool showBackgroundSelect = false;
	private bool showRaceSelect = false;
	private bool showWeapon1Select = false;
	private bool showWeapon2Select = false;
	private bool showArmorSelect = false;
	private bool showClassLevelSelect = false;
	private bool[] showSpellSelect = new bool[20];

	protected async override Task OnInitializedAsync()
	{
		armors = await characterSheetData.GetArmors();
		backgrounds = await characterSheetData.GetBackgrounds();
		characterClassLevels = await characterSheetData.GetClassLevels();
		characterClassLevels.RemoveInvalidLevelSelections(characterSheet.CharacterClassLevels);
		feats = await characterSheetData.GetAvailableFeats();
		races = await characterSheetData.GetRaces();
		skills = await characterSheetData.GetSkills();
		weapons = await characterSheetData.GetWeapons();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if(firstRender)
		{
			// TODO: Replace with a proper check (if current sheet is empty)
			if (characterSheet.CharacterClassLevels.Count == 0)
			{
				await LoadCharacterSheetState();
			}

			StateHasChanged();
		}
	}

	/// <summary>
	/// Loads active character sheet state from session storage.
	/// </summary>
	/// <returns></returns>
	private async Task LoadCharacterSheetState()
	{
		var activeBuildResult = await sessionStorage.GetAsync<string>(nameof(characterSheet.BuildReferenceId));

		if (activeBuildResult.Success)
		{
			await characterSheet.LoadBuildFromRefId(activeBuildResult.Value, characterSheetData);
		}
	}

	/// <summary>
	/// Filters available backgrounds based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterBackgrounds()
	{
		var output = await characterSheetData.GetBackgrounds();

		if(string.IsNullOrWhiteSpace(backgroundSearchText) == false)
		{
			output = output.Where(b => b.Name.Contains(backgroundSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		backgrounds = output;
	}

	/// <summary>
	/// Triggers the backgrounds filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnBackgroundSearchInput(string searchInput)
	{
		backgroundSearchText = searchInput;
		await FilterBackgrounds();
	}

	/// <summary>
	/// Marks the background selection on the character sheet and adds associated skill proficiencies.
	/// </summary>
	/// <param name="background"></param>
	/// <returns></returns>
	private async Task SelectBackground(Background background)
	{
		if(characterSheet.Background is not null)
		{
			characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(x => x.Id == characterSheet.Background.Skill1Id));
			characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(x => x.Id == characterSheet.Background.Skill2Id));
		}
		characterSheet.Background = background;
		characterSheet.SkillProficiencies.Add(skills.Find(x => x.Id == background.Skill1Id));
		characterSheet.SkillProficiencies.Add(skills.Find(x => x.Id == background.Skill2Id));

		showBackgroundSelect = false;
		backgroundSearchText = "";
		await FilterBackgrounds();

		await SaveSessionData();
	}

	/// <summary>
	/// Marks the race selection on the character sheet.
	/// </summary>
	/// <param name="race"></param>
	/// <returns></returns>
	private async Task SelectRace(Race race)
	{
		racialFeatures = await characterSheetData.GetRacialFeatures(race);
		race.RaceFeatures = racialFeatures;

		characterSheet.Race = race;

		showRaceSelect = false;
		raceSearchText = "";
		await FilterRaces();

		await characterSheet.UpdateSpeed();
		await SaveSessionData();
	}

	/// <summary>
	/// Filters available races based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterRaces()
	{
		var output = await characterSheetData.GetRaces();

		if (string.IsNullOrWhiteSpace(raceSearchText) == false)
		{
			output = output.Where(r => r.Name.Contains(raceSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		races = output;
	}

	/// <summary>
	/// Triggers the races filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnRaceSearchInput(string searchInput)
	{
		raceSearchText = searchInput;
		await FilterRaces();
	}

	/// <summary>
	/// Activates the weapon selection autocomplete for the main hand.
	/// </summary>
	/// <returns></returns>
	private async Task MainHandSelect()
	{
		showWeapon2Select = false;
		showWeapon1Select = !showWeapon1Select;
		weapon1SearchText = "";
		await FilterWeapons(weapon1SearchText);
	}

	/// <summary>
	/// Activates the weapon selection autocomplete for the off hand.
	/// </summary>
	/// <returns></returns>
	private async Task OffHandSelect()
	{
		showWeapon1Select = false;
		showWeapon2Select = !showWeapon2Select;
		weapon2SearchText = "";
		await FilterWeapons(weapon2SearchText);
	}

	/// <summary>
	/// Marks the weapon selection for the specified hand on the character sheet.
	/// </summary>
	/// <param name="weapon"></param>
	/// <param name="hand"></param>
	/// <returns></returns>
	private async Task SelectWeapon(Weapon weapon, int hand)
	{
		characterSheet.EquippedWeapons[hand] = weapon;

		if (showWeapon1Select)
		{
			showWeapon1Select = false;
			weapon1SearchText = "";
		}
		else
		{
			showWeapon2Select = false;
			weapon2SearchText = "";
		}
		await FilterWeapons("");

		await SaveSessionData();
	}

	/// <summary>
	/// Filters available weapons based on search text input and 2-handed wield possibility.
	/// </summary>
	/// <returns></returns>
	private async Task FilterWeapons(string searchText)
	{
		var output = await characterSheetData.GetWeapons();

		if (string.IsNullOrWhiteSpace(searchText) == false)
		{
			output = output.Where(w => w.Name.Contains(searchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		if(showWeapon2Select || characterSheet.EquippedWeapons[1].Name is not null)
		{
			output.RemoveAll(x => x.TwoHanded == true);
		}

		weapons = output;
	}

	/// <summary>
	/// Triggers the weapons filter on main hand weapons with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnWeapon1SearchInput(string searchInput)
	{
		weapon1SearchText = searchInput;
		await FilterWeapons(searchInput);
	}

	/// <summary>
	/// Triggers the weapons filter on off hand weapons with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnWeapon2SearchInput(string searchInput)
	{
		weapon2SearchText = searchInput;
		await FilterWeapons(searchInput);
	}

	/// <summary>
	/// Marks the armor selection on the character sheet.
	/// </summary>
	/// <param name="armor"></param>
	/// <returns></returns>
	private async Task SelectArmor(Armor armor)
	{
		characterSheet.EquippedArmor = armor;

		showArmorSelect = false;
		armorSearchText = "";
		await FilterArmors();

		await SaveSessionData();
	}

	/// <summary>
	/// Filters available armors based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterArmors()
	{
		var output = await characterSheetData.GetArmors();

		if (string.IsNullOrWhiteSpace(armorSearchText) == false)
		{
			output = output.Where(a => a.Name.Contains(armorSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		armors = output;
	}

	/// <summary>
	/// Triggers the armors filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnArmorSearchInput(string searchInput)
	{
		armorSearchText = searchInput;
		await FilterArmors();
	}

	/// <summary>
	/// Filters available class levels based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterClassLevels()
	{
		var output = await characterSheetData.GetClassLevels();
		output.RemoveInvalidLevelSelections(characterSheet.CharacterClassLevels);

		if (string.IsNullOrWhiteSpace(classLevelSearchText) == false)
		{
			output = output.Where(c => c.BaseClass.Contains(classLevelSearchText, StringComparison.InvariantCultureIgnoreCase) || c.Subclass.Contains(classLevelSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		characterClassLevels = output.OrderByDescending(x => x.Level).ToList();
	}

	/// <summary>
	/// Triggers the class level filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnClassLevelSearchInput(string searchInput)
	{
		classLevelSearchText = searchInput;
		await FilterClassLevels();
	}

	/// <summary>
	/// Triggers the class level filter and activates the display of available selections.
	/// </summary>
	/// <returns></returns>
	private async Task OnClassLevelSelectToggle()
	{
		await FilterClassLevels();
		showClassLevelSelect = !showClassLevelSelect;
	}

	/// <summary>
	/// Marks the class level selection on the character sheet and adds associated class features.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task AddClassLevel(CharacterClassLevel classLevel)
	{
		characterClassFeatures = await characterSheetData.GetClassLevelFeatures(classLevel);
		foreach(var cf in characterClassFeatures)
		{
			await cf.FormatTags();
			foreach(var t in cf.TagEntries)
			{
				await characterSheet.ParseTag(characterSheetData, t);
			}
		}
		classLevel.ClassLevelFeatures = characterClassFeatures;

		characterSheet.CharacterClassLevels.Add(classLevel);

		showClassLevelSelect = false;

		await characterSheet.UpdateHitPoints();
		await characterSheet.UpdateSpeed();
		await SaveSessionData();
		await OnClassLevelSearchInput("");
	}

	/// <summary>
	/// Removes the specified class level and all its higher occurences from the character sheet.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task RemoveClassLevel(CharacterClassLevel classLevel)
	{
		characterSheet.CharacterClassLevels.RemoveAll(x => x.BaseClass == classLevel.BaseClass && x.Level >= classLevel.Level);

		await characterSheet.UpdateHitPoints();
		await characterSheet.UpdateSpeed();
		await FilterClassLevels();
		await SaveSessionData();
	}

	/// <summary>
	/// Filters available spells based on search text input.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task FilterSpells(CharacterClassLevel classLevel)
	{
		var output = await characterSheetData.GetSpellsByListAndLevel(classLevel.BaseClass, classLevel.GetAvailableSpellLevel());

		if (string.IsNullOrWhiteSpace(spellSearchText) == false)
		{
			output = output.Where(s => s.Name.Contains(spellSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		spells = output.OrderByDescending(x => x.Level).ToList();
	}

	/// <summary>
	/// Triggers the spell filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task OnSpellSearchInput(string searchInput, CharacterClassLevel classLevel)
	{
		spellSearchText = searchInput;
		await FilterSpells(classLevel);
	}

	/// <summary>
	/// Triggers the spell filter and activates the display of available selections.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task OnSpellSelectToggle(CharacterClassLevel classLevel, int characterLevel)
	{
		await FilterSpells(classLevel);
		showSpellSelect[characterLevel] = !showSpellSelect[characterLevel];
	}

	/// <summary>
	/// Adds a spell to the learned spells list of the specified class level.
	/// </summary>
	/// <param name="spell"></param>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task AddSpell(Spell spell, CharacterClassLevel classLevel, int characterLevel)
	{
		classLevel.SpellsLearned.Add(spell);
		showSpellSelect[characterLevel] = false;
		await SaveSessionData();
		await OnSpellSearchInput("", classLevel);
	}

	/// <summary>
	/// Removes the passed in spell from the list of learned spells of specified character level.
	/// </summary>
	/// <param name="spell">The spell to remove.</param>
	/// <param name="classLevel">The class level with the list of learned spells to remove from.</param>
	/// <returns></returns>
	private async Task RemoveSpell(Spell spell, CharacterClassLevel classLevel)
	{
		characterSheet.CharacterClassLevels.Find(cl => cl.Id == classLevel.Id).SpellsLearned.Remove(spell);
		await SaveSessionData();
	}

	/// <summary>
	/// Increases the specified ability score and subtracts a corresponding amount of ability points.
	/// </summary>
	/// <param name="abilityScore"></param>
	/// <returns></returns>
	private async Task IncreaseAbilityScore(AbilityScore abilityScore)
	{
		characterSheet.AbilityScorePoints -= abilityScore.IncreaseCost;
		abilityScore.Value++;

		await characterSheet.UpdateHitPoints();
		await SaveSessionData();
	}

	/// <summary>
	/// Decreases the specified ability score and adds a corresponding amount of ability points back.
	/// </summary>
	/// <param name="abilityScore"></param>
	/// <returns></returns>
	private async Task DecreaseAbilityScore(AbilityScore abilityScore)
	{
		abilityScore.Value--;
		characterSheet.AbilityScorePoints += abilityScore.IncreaseCost;

		await characterSheet.UpdateHitPoints();
		await SaveSessionData();
	}

	/// <summary>
	/// Removes the bonus spell selected with the specified tag.
	/// </summary>
	/// <param name="tagEntry"></param>
	/// <returns></returns>
	private async Task RemoveBonusSpellFromTag(TagEntry tagEntry)
	{
		var spell = await characterSheetData.GetSpell(int.Parse(tagEntry.TagData[0]));

		characterSheet.BonusSpells.RemoveAt(characterSheet.BonusSpells.FindIndex(s => s.Id == spell.Id));
		tagEntry.TagData = new string[2];

		await SaveSessionData();
	}

	/// <summary>
	/// Removes the skill proficiency selected with the specified tag.
	/// </summary>
	/// <param name="tagEntry"></param>
	/// <returns></returns>
	private async Task RemoveSkillProficiencyFromTag(TagEntry tagEntry)
	{
		var skill = await characterSheetData.GetSkill(int.Parse(tagEntry.TagData[0]));

		characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(s => s.Id == skill.Id));
		tagEntry.TagData = new string[2];

		await SaveSessionData();
	}

	/// <summary>
	/// Removes the skill expertise selected with the specified tag.
	/// </summary>
	/// <param name="tagEntry"></param>
	/// <returns></returns>
	private async Task RemoveSkillExpertiseFromTag(TagEntry tagEntry)
	{
		var skill = await characterSheetData.GetSkill(int.Parse(tagEntry.TagData[0]));

		characterSheet.SkillExpertise.RemoveAt(characterSheet.SkillExpertise.FindIndex(s => s.Id == skill.Id));
		tagEntry.TagData = new string[2];

		await SaveSessionData();
	}

	/// <summary>
	/// Remove the skill proficiency and expertise selected with the specified tag.
	/// </summary>
	/// <param name="tagEntry"></param>
	/// <returns></returns>
	private async Task RemoveSkillAndExpertiseFromTag(TagEntry tagEntry)
	{
		var skill = await characterSheetData.GetSkill(int.Parse(tagEntry.TagData[0]));

		characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(s => s.Id == skill.Id));
		characterSheet.SkillExpertise.RemoveAt(characterSheet.SkillExpertise.FindIndex(s => s.Id == skill.Id));
		tagEntry.TagData = new string[2];

		await SaveSessionData();
	}

	/// <summary>
	/// Removes the feat selected with the specified tag.
	/// </summary>
	/// <param name="tagEntry"></param>
	/// <returns></returns>
	private async Task RemoveFeatFromTag(TagEntry tagEntry)
	{
		var feat = await characterSheetData.GetFeat(int.Parse(tagEntry.TagData[0]));

		characterSheet.Feats.RemoveAt(characterSheet.Feats.FindIndex(f => f.Id == feat.Id));
		tagEntry.TagData = new string[2];

		await SaveSessionData();
	}

	/// <summary>
	/// Removes the subfeature selected with the specified class level feature.
	/// </summary>
	/// <param name="classFeature"></param>
	/// <returns></returns>
	private async Task RemoveSubfeature(CharacterClassLevel classLevel, CharacterClassFeature subfeature)
	{
		var classFeature = classLevel.ClassLevelFeatures.Find(x => x.Name == subfeature.ParentFeatureName);
		classFeature.SubselectionsMade.Remove(subfeature.Id);
		classLevel.ClassLevelFeatures.RemoveAt(classLevel.ClassLevelFeatures.FindIndex(f => f.Id == subfeature.Id));

		await SaveSessionData();
	}

	/// <summary>
	/// Saves the current state of the character sheet to the browser's session storage.
	/// </summary>
	/// <returns></returns>
	private async Task SaveSessionData()
	{
		await characterSheet.UpdateBuildRefId();
		await sessionStorage.SetAsync(nameof(showSpellSelect), showSpellSelect);
		await sessionStorage.SetAsync(nameof(characterSheet.BuildReferenceId), characterSheet.BuildReferenceId);
	}

}