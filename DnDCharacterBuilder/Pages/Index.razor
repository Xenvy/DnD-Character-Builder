@page "/"

@inject IArmorData armorData
@inject IBackgroundData backgroundData
@inject ICharacterClassFeatureData characterClassFeatureData
@inject ICharacterClassLevelData characterClassLevelData
@inject IFeatData featData
@inject IRaceData raceData
@inject IRacialFeatureData racialFeatureData
@inject ISkillData skillData
@inject ISpellData spellData
@inject IWeaponData weaponData
@inject ICharacterSheetData characterSheetData
@inject NavigationManager navManager
@inject ProtectedSessionStorage sessionStorage

<PageTitle>DnD Character Builder</PageTitle>

<body class="character-sheet">
	<h1>Character Sheet</h1>
	<div class="summary-section sheet-row">
		<p>Level @characterSheet.CharacterLevel @characterSheet.Race?.Name Adventurer
			@if(characterSheet.CharacterClassLevels.Any())
			{
				@(" /")
				@foreach(var cl in characterSheet.CharacterClassLevels.DistinctBy(x => x.BaseClass))
				{
					@($"/ {cl.BaseClass} ")
				}
			}
		</p>
	</div>
	<!-- Race and race features section -->
	<div class="race-section sheet-row">
		<div class="race-choice-section">
			<div class="autocomplete">
				<div class="option-selection">
					<label for="raceSelection">Race: @(characterSheet.Race?.Name)</label>
					@if(characterSheet.Race is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => showRaceSwap = !showRaceSwap)"><span class="oi oi-loop-circular"></span></button>
					}
					@if(showRaceSwap)
					{
						<!-- Autocomplete-style selection of character's race -->
						<input type="text"
							   id="raceSelection"
							   placeholder="Select a race..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnRaceSearchInput((string)txt.Value))"
							   @onfocusin="(_ => showRaceSelect = !showRaceSelect)"
							   @onfocusout="(_ => OnRaceSelection())"
							   @bind-value="raceSearchText" />
						<div class="option-list">
							<ul name="raceSelectionList" class="options @(showRaceSelect ? "" : "hide")">
								@if (races?.Count > 0)
								{
									@foreach (var r in races)
									{
										<li class="option" @onclick="(_ => SelectRace(r))">
											<span class="option-text">@r.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}
				</div>
			</div>
		</div>
		<div class="race-features-section">
			@if(characterSheet.Race is not null)
			{
				<p>@characterSheet.Race.Name features:</p>
				@foreach (var rf in characterSheet.Race.RaceFeatures)
				{
					@if (!String.IsNullOrWhiteSpace(rf.Description))
					{
						<div class="feature-with-tooltip">
							@rf.Name
							<span class="tooltip-text"> @rf.Description </span>
						</div>
					}
					else
					{
						<div class="feature-no-tooltip">@rf.Name</div>
					}
				}
			}
		</div>
	</div>
	<!-- Ability scores section -->
	<div class="ability-scores-section sheet-row">
		<!-- Display character's ability scores alongside increment and decrement buttons -->
		<div class="ability-score-points">
			<p>Ability scores <br />
				Remaining points: @characterSheet.AbilityScorePoints
			</p>
		</div>
		<div class="ability-scores">
			@foreach (var a in characterSheet.AbilityScores)
			{
				<div class="ability-score-entry">
					@($"{a.Ability.ToString()}: {a.Value} [{a.Modifier}]")
					<button class="btn btn-light as-subtract-btn @(a.Value > 8 ? "" : "disabled disabled-btn")" @onclick="(_ => DecreaseAbilityScore(a))">-</button>
					<button class="btn btn-light as-add-btn @(a.CanIncrease && characterSheet.AbilityScorePoints >= a.IncreaseCost ? "" : "disabled disabled-btn")" @onclick="(_ => IncreaseAbilityScore(a))">+</button>
				</div>
			}
		</div>				
	</div>
	<!-- Background section -->
	<div class="background-section sheet-row">	
		<div class="autocomplete">
			<div class="option-selection">
				<label for="backgroundSelection">Background: @(characterSheet.Background?.Name)</label>
				@if (characterSheet.Background is not null)
				{
					<button class="btn btn-sm" @onclick="(_ => showBackgroundSwap = !showBackgroundSwap)"><span class="oi oi-loop-circular"></span></button>
				}
				@if(showBackgroundSwap)
				{
					<!-- Autocomplete-style selection of character's background -->
					<input type="text"
						   id="backgroundSelection"
						   placeholder="Select a background..."
						   class="form-control filter"
						   aria-label="Search box"
						   @oninput="((txt) => OnBackgroundSearchInput((string)txt.Value))"
						   @onfocusin="(_ => showBackgroundSelect = !showBackgroundSelect)"
						   @onfocusout="(_ => OnBackgroundSelection())"
						   @bind-value="backgroundSearchText" />
					<div class="option-list">
						<ul name="backgroundSelectionList" class="options @(showBackgroundSelect ? "" : "hide")">
							@if (backgrounds?.Count > 0)
							{
								@foreach (var b in backgrounds)
								{
									<li class="option" @onclick="(_ => SelectBackground(b))">
										<span class="option-text">@b.Name</span>
									</li>
								}
							}
							else
							{
								<li class="disabled option">No results</li>
							}
						</ul>
					</div>
				}
			</div>					
		</div>
	</div>
	<!-- Skills and saving section throw proficiencies section -->
	<div class="skills-and-saving-throws-section sheet-row">
		<div class="skills-section">
			<p>Character skills</p>
			<!-- Display all skills and their values -->
			<table name="skillsTable" class="table table-striped skills-table">
				<thead>
					<tr>
						<th>Skill</th>
						<th>Ability</th>
						<th>Ability Bonus</th>
						<th>Skill Proficiency Bonus</th>
						<th>Total</th>
					</tr>
				</thead>
				<tbody>
					@foreach (var s in skills)
					{
						<tr>
							<td>@s.Name</td>
							<td>@s.AssociatedAbilityScore</td>
							<td>@characterSheet.AbilityScores.Find(x => x.Ability == s.AssociatedAbilityScore).Modifier</td>
							<td>@(characterSheet.SkillProficiencies.Find(x => x.Name == s.Name) != null ? characterSheet.ProficiencyBonus : 0)</td>
							<td>@(@characterSheet.AbilityScores.Find(x => x.Ability == s.AssociatedAbilityScore).Modifier + (characterSheet.SkillProficiencies.Find(x => x.Name == s.Name) != null ? characterSheet.ProficiencyBonus : 0))</td>
						</tr>		
					}
				</tbody>		
			</table>
		</div>
		<div class="saving-throws-section">
			<p>Saving throws</p>
			<table name="savingThrowsTable" class="table table-striped saving-throws-table">
				<thead>
					<tr>
						<th>Saving Throw</th>
						<th>Ability Bonus</th>
						<th>Proficiency Bonus</th>
						<th>Total</th>
					</tr>
				</thead>
				<tbody>
					@foreach (var a in characterSheet.AbilityScores)
					{
						<tr>
							<td>@a.Ability</td>
							<td>@a.Modifier</td>
							<td>@(characterSheet.SavingThrowProficiencies.FindIndex(x => x == a.Ability) != -1 ? characterSheet.ProficiencyBonus : 0)</td>
							<td>@(a.Modifier + (characterSheet.SavingThrowProficiencies.FindIndex(x => x == a.Ability) != -1 ? characterSheet.ProficiencyBonus : 0))</td>
						</tr>
					}
				</tbody>
			</table>
		</div>
	</div>
	<!-- Weapon and armor section -->
	<div class="weapons-and-armors-section sheet-row">
		<div class="weapons-section">
			<div class="autocomplete">
				<div class="option-selection">
					<label for="weapon1Selection">Main hand: @characterSheet.EquippedWeapons[0]?.Name</label>
					@if (characterSheet.EquippedWeapons[0].Name is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => showWeapon1Swap = !showWeapon1Swap)"><span class="oi oi-loop-circular"></span></button>
					}
					@if(showWeapon1Swap)
					{
						<!-- Autocomplete-style selection of character's main hand weapon -->
						<input type="text"
							   id="weapon1Selection"
							   placeholder="Equip a weapon..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnWeapon1SearchInput((string)txt.Value))"
							   @onfocusin="(_ => MainHandSelect())"
							   @onfocusout="(_ => OnWeaponSelection())"
							   @bind-value="weapon1SearchText" />
						<div class="option-list">
							<ul name="weaponSelectionList" class="options @(showWeapon1Select ? "" : "hide")">
								@if (weapons?.Count > 0)
								{
									<li class="option" @onclick="(_ => SelectWeapon(new Weapon(), 0))"><span class="option-text">(Empty hand)</span></li>
									@foreach (var w in weapons)
									{
										<li class="option" @onclick="(_ => SelectWeapon(w, 0))">
											<span class="option-text">@w.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}
				</div>
			</div>
			<div>
				<p>Main hand attack: @characterSheet.EquippedWeapons[0].Name @($"+{characterSheet.AbilityScores[0].Modifier + characterSheet.ProficiencyBonus}") @($"{characterSheet.EquippedWeapons[0].Damage}+{characterSheet.AbilityScores[0].Modifier}")</p>
			</div>
			@if(characterSheet.EquippedWeapons[0]?.TwoHanded == false)
			{
				<div class="autocomplete">
					<div class="option-selection">
						<label for="weapon2Selection">Off hand: @characterSheet.EquippedWeapons[1]?.Name</label>
						@if (characterSheet.EquippedWeapons[1].Name is not null)
						{
							<button class="btn btn-sm" @onclick="(_ => showWeapon2Swap = !showWeapon2Swap)"><span class="oi oi-loop-circular"></span></button>
						}
						@if(showWeapon2Swap)
						{
							<!-- Autocomplete-style selection of character's off-hand weapon -->
							<input type="text"
								   id="weapon2Selection"
								   placeholder="Equip a weapon..."
								   class="form-control filter"
								   aria-label="Search box"
								   @oninput="((txt) => OnWeapon2SearchInput((string)txt.Value))"
								   @onfocusin="(_ => OffHandSelect())"
								   @onfocusout="(_ => OnWeaponSelection())"
								   @bind-value="weapon2SearchText" />
							<div class="option-list">
								<ul name="weaponSelectionList" class="options @(showWeapon2Select ? "" : "hide")">
									@if (weapons?.Count > 0)
									{
										<li class="option" @onclick="(_ => SelectWeapon(new Weapon(), 1))"><span class="option-text">(Empty hand)</span></li>
										@foreach (var w in weapons)
										{
											<li class="option" @onclick="(_ => SelectWeapon(w, 1))">
												<span class="option-text">@w.Name</span>
											</li>
										}
									}
									else
									{
										<li class="disabled option">No results</li>
									}
								</ul>
							</div>
						}	
					</div>
				</div>
				<div>
					<p>Off-hand attack: @characterSheet.EquippedWeapons[1].Name @($"+{characterSheet.AbilityScores[0].Modifier + characterSheet.ProficiencyBonus}") @characterSheet.EquippedWeapons[1].Damage</p>
				</div>
			}
		</div>
		<div class="armor-section">
			<div class="autocomplete">
				<div class="option-selection">
					<label for="armorSelection">Equipped armor: @characterSheet.EquippedArmor.Name</label>
					@if (characterSheet.EquippedArmor.Name is not null)
					{
						<button class="btn btn-sm" @onclick="(_ => showArmorSwap = !showArmorSwap)"><span class="oi oi-loop-circular"></span></button>
					}
					@if(showArmorSwap)
					{
						<!-- Autocomplete-style selection of character's armor -->
						<input type="text"
							   id="armorSelection"
							   placeholder="Equip armor..."
							   class="form-control filter"
							   aria-label="Search box"
							   @oninput="((txt) => OnArmorSearchInput((string)txt.Value))"
							   @onfocusin="(_ => showArmorSelect = !showArmorSelect)"
							   @onfocusout="(_ => OnArmorSelection())"
							   @bind-value="armorSearchText" />
						<div class="option-list">
							<ul name="armorSelectionList" class="options @(showArmorSelect ? "" : "hide")">
								@if (armors?.Count > 0)
								{
									<li class="option" @onclick="(_ => SelectArmor(new Armor()))"><span class="option-text">(No armor)</span></li>
									@foreach (var a in armors)
									{
										<li class="option" @onclick="(_ => SelectArmor(a))">
											<span class="option-text">@a.Name</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					}		
				</div>
			</div>
			<div>
				<p>Current Armor Class: @(characterSheet.EquippedArmor.Name is null ? 10 : characterSheet.EquippedArmor.ArmorClass) base + @(characterSheet.AbilityScores[1].Modifier > characterSheet.EquippedArmor.MaxDexBonus ? characterSheet.EquippedArmor.MaxDexBonus : characterSheet.AbilityScores[1].Modifier) dexterity bonus</p>
			</div>
		</div>
	</div>
	<!-- Spells section -->
	<div class="spells-section sheet-row">
		<div>
			<p>Spells</p>
			@if (characterSheet.CharacterClassLevels.Count > 0)
			{
				@foreach (var cl in characterSheet.CharacterClassLevels)
				{
					@if(cl.SpellsLearned.Count > 0)
					{
						<p>@($"{cl.BaseClass} - {cl.Subclass} level {cl.Level}") spells:</p>
						@foreach(var s in cl.SpellsLearned)
						{
							<div class="feature-with-tooltip">
								@s.Name
								<span class="spell-tooltip-text"> @s.Description </span>
							</div>
							<button class="btn btn-light remove-spell-button" @onclick="(_ => RemoveSpell(s, cl))">-</button>
						}
					}
					@if (cl.GetNewSpellCount() > cl.SpellsLearned.Count)
					{
						<p>Select a spell for @cl.BaseClass level @cl.Level (@(cl.GetNewSpellCount() - cl.SpellsLearned.Count) remaining):</p>
						<div class="autocomplete">
							<div class="option-selection">
								<!-- Autocomplete-style selection of character's spells -->
								<input type="text"
									   id="spellSelection"
									   placeholder="Select a spell..."
									   class="form-control filter"
									   aria-label="Search box"
									   @bind-value="spellSearchText"
									   @oninput="((txt) => OnSpellSearchInput((string)txt.Value, cl))"
									   @onfocusin="(_ => OnSpellSelectFocusIn(cl))"
									   @onfocusout="(_ => OnSpellSelection(cl.Id))" />
								<div class="option-list">
									<ul name="spellSelectionList" class="options @(showSpellSelect[cl.Id] ? "" : "hide")">
										@if (spells?.Count > 0)
										{
											@foreach (var s in spells)
											{
												<li class="option" @onclick="(_ => AddSpell(s, cl))">
													<span class="option-text">@s.Name</span>
												</li>
											}
										}
										else
										{
											<li class="disabled option">No results</li>
										}
									</ul>
								</div>
							</div>
						</div>
					}		
				}
			}
		</div>
	</div>
	<!-- Class levels and features section -->
	<div class="levels-section sheet-row">
		<div class="level-choice-section">
			<p>
				Levels:
				<br />
				<!-- Display all current character's levels -->
				@if (characterSheet.CharacterClassLevels.Count > 0)
				{
					@foreach (var cl in characterSheet.CharacterClassLevels)
					{
						@($"{cl.BaseClass} - {cl.Subclass} {cl.Level} ")
						<button class="btn btn-light" @onclick="(_ => RemoveClassLevel(cl))">-</button>
						<br />
					}
				}
			</p>
			@if (characterSheet.CharacterClassLevels.Count < 20)
			{
				<div class="autocomplete">
					<div class="option-selection">
						<!-- Autocomplete-style selection of character's class levels -->
						<input type="text"
							   id="classLevelSelection"
							   placeholder="Select a class..."
							   class="form-control filter"
							   aria-label="Search box"
							   @bind-value=classLevelSearchText
							   @oninput="((txt) => OnClassLevelSearchInput((string)txt.Value))"
							   @onfocusin="(_ => OnClassLevelSelectFocusIn())"
							   @onfocusout="(_ => OnClassLevelSelection())" />
						<div class="option-list">
							<ul name="classLevelSelection" class="options @(showClassLevelSelect ? "" : "hide")">
								@if (characterClassLevels?.Count > 0)
								{
									@foreach (var cl in characterClassLevels)
									{
										<li class="option" @onclick="(_ => AddClassLevel(cl))">
											<span class="option-text">@($"{cl.BaseClass} - {cl.Subclass} {cl.Level}")</span>
										</li>
									}
								}
								else
								{
									<li class="disabled option">No results</li>
								}
							</ul>
						</div>
					</div>
				</div>
			}		
		</div>
		<div class="level-features-section">
			<!-- Display all acquired level features, grouped by level -->
			@if (characterSheet.CharacterClassLevels.Count > 0)
			{
				@for (int i = 0; i < characterSheet.CharacterClassLevels.Count; i++)
				{
					<p>Character level @(i + 1) / @($"{characterSheet.CharacterClassLevels[i].BaseClass} - {characterSheet.CharacterClassLevels[i].Subclass} level {characterSheet.CharacterClassLevels[i].Level}") features:</p>
					@foreach (var f in characterSheet.CharacterClassLevels[i].ClassLevelFeatures)
					{
						@if (!String.IsNullOrWhiteSpace(f.Description))
						{
							<div class="feature-with-tooltip">
								@f.Name
								<span class="tooltip-text"> @f.Description </span>
							</div>
						}
						else
						{
							<div class="feature-no-tooltip">@f.Name</div>
						}
						<!--Class feature tag parser-->
						@foreach (var te in f.TagEntries)
						{
							switch(te.Tag)
							{
								case "skillSelectAny":
									<!-- <SkillSelectInput> -->
									break;
								case "skillSelect":
									<!-- <SkillSelectInput> -->
									break;
								case "skillSelectExpertise":
									<!-- <SkillSelectInput> -->
									break;
								case "expertise":
									<!-- <SkillSelectInput> -->
									break;
								case "spellSelect":
									<!-- <SpellSelectInput> -->
									break;
								case "spellSelectAny":
									<!-- <SpellSelectInput> -->
									break;
								case "spellMastery":
									<!-- <SpellSelectInput> -->
									break;
								case "feat":
									<!-- <FeatSelectInput> -->
									break;
								default:
									break;
							}
						}
					}
				}
			}
		</div>
	</div>
</body>

@code
{
	private List<Armor> armors = new();
	private List<Background> backgrounds = new();
	private List<CharacterClassFeature> characterClassFeatures = new();
	private List<CharacterClassLevel> characterClassLevels = new();
	private List<Feat> feats = new();
	private List<Race> races = new();
	private List<RacialFeature> racialFeatures = new();
	private List<Skill> skills = new();
	private List<Spell> spells = new();
	private List<Weapon> weapons = new();

	private string backgroundSearchText = "";
	private string raceSearchText = "";
	private string weapon1SearchText = "";
	private string weapon2SearchText = "";
	private string armorSearchText = "";
	private string classLevelSearchText = "";
	private string spellSearchText = "";

	private bool showBackgroundSelect = false;
	private bool showRaceSelect = false;
	private bool showWeapon1Select = false;
	private bool showWeapon2Select = false;
	private bool showArmorSelect = false;
	private bool showClassLevelSelect = false;
	private Dictionary<int, bool> showSpellSelect = new();

	private bool showRaceSwap = true;
	private bool showBackgroundSwap = true;
	private bool showWeapon1Swap = true;
	private bool showWeapon2Swap = true;
	private bool showArmorSwap = true;
	CancellationTokenSource tokenSource;

	private CharacterSheet characterSheet = new();

	protected async override Task OnInitializedAsync()
	{
		armors = await characterSheetData.GetArmors();
		backgrounds = await characterSheetData.GetBackgrounds();
		characterClassLevels = await characterSheetData.GetClassLevels();
		characterClassLevels.RemoveInvalidLevelSelections(characterSheet.CharacterClassLevels);
		feats = await characterSheetData.GetAvailableFeats();
		races = await characterSheetData.GetRaces();
		skills = await characterSheetData.GetSkills();
		weapons = await characterSheetData.GetWeapons();
	}

	protected override async Task OnAfterRenderAsync(bool firstRender)
	{
		if(firstRender)
		{
			await LoadCharacterSheetState();
			foreach(var s in showSpellSelect)
			{
				showSpellSelect[s.Key] = false;
			}

			if(characterSheet.EquippedWeapons[0].Name is not null)
			{
				showWeapon1Swap = false;
			}
			if(characterSheet.EquippedWeapons[1].Name is not null)
			{
				showWeapon2Swap = false;
			}
			if(characterSheet.EquippedArmor.Name is not null)
			{
				showArmorSwap = false;
			}

			StateHasChanged();
		}
	}

	/// <summary>
	/// Loads active character sheet state from session storage.
	/// </summary>
	/// <returns></returns>
	private async Task LoadCharacterSheetState()
	{
		var activeShowSpellsResult = await sessionStorage.GetAsync<Dictionary<int, bool>>(nameof(showSpellSelect));
		var activeSheetResult = await sessionStorage.GetAsync<CharacterSheet>(nameof(characterSheet));

		showSpellSelect = activeShowSpellsResult.Success ? activeShowSpellsResult.Value : new Dictionary<int, bool>();
		characterSheet = activeSheetResult.Success ? activeSheetResult.Value : new CharacterSheet();
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on background selection to make sure the choice goes through.
	/// </summary>
	/// <returns></returns>
	private async Task OnBackgroundSelection()
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			showBackgroundSelect = false;
			showBackgroundSwap = false;
			backgroundSearchText = "";
			await InvokeAsync(StateHasChanged);
			await FilterBackgrounds();
		}, tokenSource.Token);	
	}

	/// <summary>
	/// Filters available backgrounds based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterBackgrounds()
	{
		var output = await characterSheetData.GetBackgrounds();

		if(string.IsNullOrWhiteSpace(backgroundSearchText) == false)
		{
			output = output.Where(b => b.Name.Contains(backgroundSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		backgrounds = output;
	}

	/// <summary>
	/// Triggers the backgrounds filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnBackgroundSearchInput(string searchInput)
	{
		backgroundSearchText = searchInput;
		await FilterBackgrounds();
	}

	/// <summary>
	/// Marks the background selection on the character sheet and adds associated skill proficiencies.
	/// </summary>
	/// <param name="background"></param>
	/// <returns></returns>
	private async Task SelectBackground(Background background)
	{
		if(characterSheet.Background is not null)
		{
			characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(x => x.Id == characterSheet.Background.Skill1Id));
			characterSheet.SkillProficiencies.RemoveAt(characterSheet.SkillProficiencies.FindIndex(x => x.Id == characterSheet.Background.Skill2Id));
		}
		characterSheet.Background = background;
		characterSheet.SkillProficiencies.Add(skills.Find(x => x.Id == background.Skill1Id));
		characterSheet.SkillProficiencies.Add(skills.Find(x => x.Id == background.Skill2Id));

		await SaveSessionData();
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on race selection to make sure the choice goes through.
	/// </summary>
	/// <returns></returns>
	private async Task OnRaceSelection()
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			showRaceSelect = false;
			showRaceSwap = false;
			raceSearchText = "";
			await InvokeAsync(StateHasChanged);
			await FilterRaces();
		}, tokenSource.Token);
	}

	/// <summary>
	/// Marks the race selection on the character sheet.
	/// </summary>
	/// <param name="race"></param>
	/// <returns></returns>
	private async Task SelectRace(Race race)
	{
		racialFeatures = await characterSheetData.GetRacialFeatures(race);
		race.RaceFeatures = racialFeatures;

		characterSheet.Race = race;

		await SaveSessionData();
	}

	/// <summary>
	/// Filters available races based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterRaces()
	{
		var output = await characterSheetData.GetRaces();

		if (string.IsNullOrWhiteSpace(raceSearchText) == false)
		{
			output = output.Where(r => r.Name.Contains(raceSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		races = output;
	}

	/// <summary>
	/// Triggers the races filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnRaceSearchInput(string searchInput)
	{
		raceSearchText = searchInput;
		await FilterRaces();
	}

	/// <summary>
	/// Activates the weapon selection autocomplete for the main hand.
	/// </summary>
	/// <returns></returns>
	private async Task MainHandSelect()
	{
		showWeapon2Select = false;
		showWeapon1Select = true;
		weapon1SearchText = "";
		await FilterWeapons(weapon1SearchText);
	}

	/// <summary>
	/// Activates the weapon selection autocomplete for the off hand.
	/// </summary>
	/// <returns></returns>
	private async Task OffHandSelect()
	{
		showWeapon1Select = false;
		showWeapon2Select = true;
		weapon2SearchText = "";
		await FilterWeapons(weapon2SearchText);
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on weapon selection to make sure the choice goes through.
	/// </summary>
	/// <returns></returns>
	private async Task OnWeaponSelection()
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			if(showWeapon1Select)
			{
				showWeapon1Select = false;
				if(characterSheet.EquippedWeapons[0].Name is not null)
				{
					showWeapon1Swap = false;
				}
				weapon1SearchText = "";
			}
			else
			{
				showWeapon2Select = false;
				if (characterSheet.EquippedWeapons[1].Name is not null)
				{
					showWeapon2Swap = false;
				}
				weapon2SearchText = "";
			}
			await InvokeAsync(StateHasChanged);
			await FilterWeapons("");
		}, tokenSource.Token);
	}

	/// <summary>
	/// Marks the weapon selection for the specified hand on the character sheet.
	/// </summary>
	/// <param name="weapon"></param>
	/// <param name="hand"></param>
	/// <returns></returns>
	private async Task SelectWeapon(Weapon weapon, int hand)
	{
		characterSheet.EquippedWeapons[hand] = weapon;

		await SaveSessionData();
	}

	/// <summary>
	/// Filters available weapons based on search text input and 2-handed wield possibility.
	/// </summary>
	/// <returns></returns>
	private async Task FilterWeapons(string searchText)
	{
		var output = await characterSheetData.GetWeapons();

		if (string.IsNullOrWhiteSpace(searchText) == false)
		{
			output = output.Where(w => w.Name.Contains(searchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		if(showWeapon2Select || characterSheet.EquippedWeapons[1].Name is not null)
		{
			output.RemoveAll(x => x.TwoHanded == true);
		}

		weapons = output;
	}

	/// <summary>
	/// Triggers the weapons filter on main hand weapons with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnWeapon1SearchInput(string searchInput)
	{
		weapon1SearchText = searchInput;
		await FilterWeapons(searchInput);
	}

	/// <summary>
	/// Triggers the weapons filter on off hand weapons with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnWeapon2SearchInput(string searchInput)
	{
		weapon2SearchText = searchInput;
		await FilterWeapons(searchInput);
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on armor selection to make sure the choice goes through.
	/// </summary>
	/// <returns></returns>
	private async Task OnArmorSelection()
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			showArmorSelect = false;
			if(characterSheet.EquippedArmor.Name is not null)
			{
				showArmorSwap = false;
			}
			armorSearchText = "";
			await InvokeAsync(StateHasChanged);
			await FilterArmors();
		}, tokenSource.Token);
	}

	/// <summary>
	/// Marks the armor selection on the character sheet.
	/// </summary>
	/// <param name="armor"></param>
	/// <returns></returns>
	private async Task SelectArmor(Armor armor)
	{
		characterSheet.EquippedArmor = armor;

		await SaveSessionData();
	}

	/// <summary>
	/// Filters available armors based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterArmors()
	{
		var output = await characterSheetData.GetArmors();

		if (string.IsNullOrWhiteSpace(armorSearchText) == false)
		{
			output = output.Where(a => a.Name.Contains(armorSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		armors = output;
	}

	/// <summary>
	/// Triggers the armors filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnArmorSearchInput(string searchInput)
	{
		armorSearchText = searchInput;
		await FilterArmors();
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on class level selection to make sure the choice goes through.
	/// </summary>
	/// <returns></returns>
	private async Task OnClassLevelSelection()
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			showClassLevelSelect = false;
			await InvokeAsync(StateHasChanged);
		}, tokenSource.Token);
	}

	/// <summary>
	/// Filters available class levels based on search text input.
	/// </summary>
	/// <returns></returns>
	private async Task FilterClassLevels()
	{
		var output = await characterSheetData.GetClassLevels();
		output.RemoveInvalidLevelSelections(characterSheet.CharacterClassLevels);

		if (string.IsNullOrWhiteSpace(classLevelSearchText) == false)
		{
			output = output.Where(c => c.BaseClass.Contains(classLevelSearchText, StringComparison.InvariantCultureIgnoreCase) || c.Subclass.Contains(classLevelSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		characterClassLevels = output.OrderByDescending(x => x.Level).ToList();
	}

	/// <summary>
	/// Triggers the class level filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <returns></returns>
	private async Task OnClassLevelSearchInput(string searchInput)
	{
		classLevelSearchText = searchInput;
		await FilterClassLevels();
	}

	/// <summary>
	/// Triggers the class level filter and activates the display of available selections.
	/// </summary>
	/// <returns></returns>
	private async Task OnClassLevelSelectFocusIn()
	{
		await FilterClassLevels();
		showClassLevelSelect = !showClassLevelSelect;
	}

	/// <summary>
	/// Marks the class level selection on the character sheet and adds associated class features.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task AddClassLevel(CharacterClassLevel classLevel)
	{
		characterClassFeatures = await characterSheetData.GetClassLevelFeatures(classLevel);
		foreach(var cf in characterClassFeatures)
		{
			await cf.FormatTags();
		}
		classLevel.ClassLevelFeatures = characterClassFeatures;

		characterSheet.CharacterClassLevels.Add(classLevel);

		showSpellSelect.Add(classLevel.Id, false);

		await SaveSessionData();
		await OnClassLevelSearchInput("");
	}

	/// <summary>
	/// Removes the specified class level and all its higher occurences from the character sheet.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task RemoveClassLevel(CharacterClassLevel classLevel)
	{
		characterSheet.CharacterClassLevels.RemoveAll(x => x.BaseClass == classLevel.BaseClass && x.Level >= classLevel.Level);
		showSpellSelect.Remove(classLevel.Id);
		await FilterClassLevels();
		await SaveSessionData();
	}

	/// <summary>
	/// Delays the autocomplete option list hiding on spell selection to make sure the choice goes through.
	/// </summary>
	/// <param name="level"></param>
	/// <returns></returns>
	private async Task OnSpellSelection(int level)
	{
		tokenSource = new CancellationTokenSource();
		await Task.Factory.StartNew(async () =>
		{
			await Task.Delay(100);
			showSpellSelect[level] = false;
			await InvokeAsync(StateHasChanged);
		}, tokenSource.Token);
	}

	/// <summary>
	/// Filters available spells based on search text input.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task FilterSpells(CharacterClassLevel classLevel)
	{
		var output = await characterSheetData.GetAvailableSpells(classLevel);

		if (string.IsNullOrWhiteSpace(spellSearchText) == false)
		{
			output = output.Where(s => s.Name.Contains(spellSearchText, StringComparison.InvariantCultureIgnoreCase)).ToList();
		}

		spells = output.OrderByDescending(x => x.Level).ToList();
	}

	/// <summary>
	/// Triggers the spell filter with the supplied search text.
	/// </summary>
	/// <param name="searchInput"></param>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task OnSpellSearchInput(string searchInput, CharacterClassLevel classLevel)
	{
		spellSearchText = searchInput;
		await FilterSpells(classLevel);
	}

	/// <summary>
	/// Triggers the spell filter and activates the display of available selections.
	/// </summary>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task OnSpellSelectFocusIn(CharacterClassLevel classLevel)
	{
		await FilterSpells(classLevel);
		showSpellSelect[classLevel.Id] = !showSpellSelect[classLevel.Id];
	}

	/// <summary>
	/// Adds a spell to the learned spells list of the specified class level.
	/// </summary>
	/// <param name="spell"></param>
	/// <param name="classLevel"></param>
	/// <returns></returns>
	private async Task AddSpell(Spell spell, CharacterClassLevel classLevel)
	{
		classLevel.SpellsLearned.Add(spell);
		await SaveSessionData();
		await OnSpellSearchInput("", classLevel);
	}

	/// <summary>
	/// Removes the passed in spell from the list of learned spells of specified character level.
	/// </summary>
	/// <param name="spell">The spell to remove.</param>
	/// <param name="classLevel">The class level with the list of learned spells to remove from.</param>
	/// <returns></returns>
	private async Task RemoveSpell(Spell spell, CharacterClassLevel classLevel)
	{
		characterSheet.CharacterClassLevels.Find(cl => cl.Id == classLevel.Id).SpellsLearned.Remove(spell);
		await SaveSessionData();
	}

	/// <summary>
	/// Increases the specified ability score and subtracts a corresponding amount of ability points.
	/// </summary>
	/// <param name="abilityScore"></param>
	/// <returns></returns>
	private async Task IncreaseAbilityScore(AbilityScore abilityScore)
	{
		characterSheet.AbilityScorePoints -= abilityScore.IncreaseCost;
		abilityScore.Value++;

		await SaveSessionData();
	}

	/// <summary>
	/// Decreases the specified ability score and adds a corresponding amount of ability points back.
	/// </summary>
	/// <param name="abilityScore"></param>
	/// <returns></returns>
	private async Task DecreaseAbilityScore(AbilityScore abilityScore)
	{
		abilityScore.Value--;
		characterSheet.AbilityScorePoints += abilityScore.IncreaseCost;

		await SaveSessionData();
	}

	/// <summary>
	/// Saves the current state of the character sheet to the browser's session storage.
	/// </summary>
	/// <returns></returns>
	private async Task SaveSessionData()
	{
		await sessionStorage.SetAsync(nameof(showSpellSelect), showSpellSelect);
		await sessionStorage.SetAsync(nameof(characterSheet), characterSheet);
	}

}